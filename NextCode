using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Wordprocessing;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using Word = Microsoft.Office.Interop.Word;

namespace BPAServiceIntegration
{
    public class FinalPDFGeneration
    {
        #region Language Models

        public class LangSettings
        {
            public int Offset;
            public string Font;
            public LangSettings(int offset, string font)
            {
                Offset = offset;
                Font = font;
            }
        }

        private static class IndicMaster
        {
            public static readonly Dictionary<string, int> Vyanjan =
                new Dictionary<string, int>
            {
                {"khy",0x16},{"ghy",0x18},{"k",0x15},{"kh",0x16},{"g",0x17},{"gh",0x18},{"ng",0x19},
                {"chh",0x1b},{"ch",0x1a},{"j",0x1c},{"jh",0x1d},{"ny",0x1e},
                {"tth",0x20},{"tt",0x1f},{"ddh",0x22},{"dd",0x21},{"nn",0x23},
                {"th",0x25},{"t",0x24},{"dh",0x27},{"d",0x26},{"n",0x28},
                {"ph",0x2b},{"p",0x2a},{"bh",0x2d},{"b",0x2c},{"m",0x2e},
                {"y",0x2f},{"r",0x30},{"l",0x32},{"v",0x35},{"w",0x35},
                {"sh",0x36},{"ssh",0x37},{"s",0x38},{"h",0x39}
            };

            public static readonly Dictionary<string, int> SwarStart =
                new Dictionary<string, int>
            {
                {"aa",0x06},{"a",0x05},{"ee",0x0a},{"i",0x08},
                {"oo",0x0c},{"u",0x0b},{"ai",0x10},{"e",0x0f},
                {"au",0x14},{"o",0x13}
            };

            public static readonly Dictionary<string, int> MatraMid =
                new Dictionary<string, int>
            {
                {"aa",0x3e},{"ee",0x40},{"i",0x3f},{"oo",0x42},
                {"u",0x41},{"ai",0x48},{"e",0x47},{"au",0x4c},{"o",0x4b}
            };
        }

        #endregion

        #region Language Configuration (ALL INDIAN LANGUAGES)

        public static readonly Dictionary<string, LangSettings> LangConfig =
            new Dictionary<string, LangSettings>
        {
            // Devanagari family
            { "hi-IN",  new LangSettings(0x0900,"Mangal") }, // Hindi
            { "mr-IN",  new LangSettings(0x0900,"Mangal") }, // Marathi
            { "awa-IN", new LangSettings(0x0900,"Mangal") }, // Awadhi
            { "mai-IN", new LangSettings(0x0900,"Mangal") }, // Maithili
            { "bho-IN", new LangSettings(0x0900,"Mangal") }, // Bhojpuri
            { "raj-IN", new LangSettings(0x0900,"Mangal") }, // Rajasthani
            { "kok-IN", new LangSettings(0x0900,"Mangal") }, // Konkani

            // Gujarati
            { "gu-IN",  new LangSettings(0x0A80,"Shruti") },

            // Punjabi (Gurmukhi)
            { "pa-IN",  new LangSettings(0x0A00,"Raavi") },

            // Bengali / Assamese
            { "bn-IN",  new LangSettings(0x0980,"Vrinda") },
            { "as-IN",  new LangSettings(0x0980,"Vrinda") },

            // Odia
            { "or-IN",  new LangSettings(0x0B00,"Kalinga") },

            // Tamil
            { "ta-IN",  new LangSettings(0x0B80,"Latha") },

            // Telugu
            { "te-IN",  new LangSettings(0x0C00,"Gautami") },

            // Kannada
            { "kn-IN",  new LangSettings(0x0C80,"Tunga") },

            // Malayalam
            { "ml-IN",  new LangSettings(0x0D00,"Kartika") }
        };

        #endregion

        #region Process Document (Word â†’ PDF)

        public byte[] ProcessDocument(string xmlString)
        {
            Word.Application wordApp = null;
            Word.Document wordDoc = null;
            string outputDocx = string.Empty;
            string outputPdf = string.Empty;
            string key = string.Empty;

            try
            {
                Log("START", "Processing document");

                key = CallKey();
                string decryptedXml = PasswordDecrypt(xmlString, key);

                int first = decryptedXml.IndexOf('<');
                int last = decryptedXml.LastIndexOf('>');
                decryptedXml = decryptedXml.Substring(first, last - first + 1);

                XmlDocument xml = new XmlDocument();
                xml.LoadXml(decryptedXml);

                string langCode = xml.SelectSingleNode("//language")?.InnerText ?? "en-IN";
                Log("LANG", langCode);

                LangSettings cfg = LangConfig.ContainsKey(langCode)
                    ? LangConfig[langCode]
                    : new LangSettings(0, "Calibri");

                string baseDir = @"E:\CBBranch4.6";
                string templatePath = xml.SelectSingleNode("//templatePath")?.InnerText;
                string source = Path.Combine(baseDir, "RTF", Path.GetFileName(templatePath));

                string ts = DateTime.Now.ToString("yyyyMMddHHmmssfff");
                outputDocx = Path.Combine(baseDir, "RTFTEMP", $"TMP_{ts}.docx");
                outputPdf = Path.Combine(baseDir, "RTFTEMP", $"TMP_{ts}.pdf");

                File.Copy(source, outputDocx, true);

                using (WordprocessingDocument doc = WordprocessingDocument.Open(outputDocx, true))
                {
                    Regex rx = new Regex(@"\|\|\s*(.*?)\s*\|\|");

                    var sections = new List<OpenXmlCompositeElement>
                    {
                        doc.MainDocumentPart.Document.Body
                    };
                    sections.AddRange(doc.MainDocumentPart.HeaderParts.Select(h => h.Header));
                    sections.AddRange(doc.MainDocumentPart.FooterParts.Select(f => f.Footer));

                    foreach (var section in sections)
                    {
                        foreach (var para in section.Descendants<Paragraph>())
                        {
                            while (true)
                            {
                                Match m = rx.Match(para.InnerText);
                                if (!m.Success) break;

                                string field = m.Groups[1].Value;
                                string raw = xml.SelectSingleNode($"//*[local-name()='{field}']")?.InnerText ?? "";

                                Log("FIELD", $"{field} = [{raw}]");

                                string finalVal = (langCode != "en-IN")
                                    ? Transliterate(raw, langCode)
                                    : raw;

                                ReplaceTextInExistingRuns(
                                    para, m.Index, m.Length, finalVal, cfg.Font);
                            }
                        }
                    }
                }

                wordApp = new Word.Application { Visible = false };
                wordDoc = wordApp.Documents.Open(outputDocx, ReadOnly: true);
                wordDoc.ExportAsFixedFormat(outputPdf, Word.WdExportFormat.wdExportFormatPDF);

                //return File.ReadAllBytes(outputPdf);
                byte[] rawPdfBytes = File.ReadAllBytes(outputPdf);
                return Encoding.UTF8.GetBytes(PasswordEncrypt(Convert.ToBase64String(rawPdfBytes), key));
            }
            finally
            {
                if (wordDoc != null) { wordDoc.Close(false); Marshal.ReleaseComObject(wordDoc); }
                if (wordApp != null) { wordApp.Quit(); Marshal.ReleaseComObject(wordApp); }
                if (File.Exists(outputDocx)) File.Delete(outputDocx);
                if (File.Exists(outputPdf)) File.Delete(outputPdf);
                Log("END", "Processing completed");
            }
        }

        #endregion

        #region Transliteration (LOCKED LOGIC)

        public string Transliterate(string input, string langCode)
        {
            Log("TRANSLIT-IN", input);

            if (!LangConfig.ContainsKey(langCode) || string.IsNullOrWhiteSpace(input))
                return input;

            int offset = LangConfig[langCode].Offset;
            StringBuilder result = new StringBuilder();

            string[] words = input.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

            foreach (string word in words)
            {
                if (word.Length <= 1 ||
                    Regex.IsMatch(word, @"\d") ||
                    Regex.IsMatch(word, @"[^a-zA-Z]") ||
                    Regex.IsMatch(word, @"^[A-Z]+$"))
                {
                    result.Append(word).Append(" ");
                    continue;
                }

                string w = word.ToLower();
                int i = 0;
                StringBuilder wOut = new StringBuilder();

                while (i < w.Length)
                {
                    if (i == 0)
                    {
                        var sw = IndicMaster.SwarStart.Keys
                            .OrderByDescending(k => k.Length)
                            .FirstOrDefault(k => w.Substring(i).StartsWith(k));
                        if (sw != null)
                        {
                            wOut.Append((char)(offset + IndicMaster.SwarStart[sw]));
                            i += sw.Length;
                            continue;
                        }
                    }

                    var v = IndicMaster.Vyanjan.Keys
                        .OrderByDescending(k => k.Length)
                        .FirstOrDefault(k => w.Substring(i).StartsWith(k));
                    if (v != null)
                    {
                        wOut.Append((char)(offset + IndicMaster.Vyanjan[v]));
                        i += v.Length;

                        if (i < w.Length)
                        {
                            var m = IndicMaster.MatraMid.Keys
                                .OrderByDescending(k => k.Length)
                                .FirstOrDefault(k => w.Substring(i).StartsWith(k));
                            if (m != null)
                            {
                                wOut.Append((char)(offset + IndicMaster.MatraMid[m]));
                                i += m.Length;
                                continue;
                            }
                            if (w[i] == 'a') { i++; continue; }
                        }
                        continue;
                    }
                    i++;
                }

                result.Append(wOut).Append(" ");
            }

            string finalText = result.ToString().Trim();
            Log("TRANSLIT-OUT", finalText);
            return finalText;
        }

        #endregion

        #region OpenXML Replace

        private void ReplaceTextInExistingRuns(
            Paragraph para, int startIndex, int length, string replacement, string font)
        {
            var texts = para.Descendants<Text>().ToList();
            int pos = 0, remaining = length;
            bool done = false;

            foreach (var t in texts)
            {
                int len = t.Text.Length;
                if (!done && startIndex >= pos && startIndex < pos + len)
                {
                    int local = startIndex - pos;
                    int take = Math.Min(len - local, remaining);
                    t.Text = t.Text.Substring(0, local) + replacement + t.Text.Substring(local + take);

                    if (t.Parent is Run r)
                    {
                        if (r.RunProperties == null) r.RunProperties = new RunProperties();
                        r.RunProperties.RunFonts =
                            new RunFonts { Ascii = font, HighAnsi = font, ComplexScript = font };
                    }

                    remaining -= take;
                    done = true;
                }
                else if (done && remaining > 0)
                {
                    int cut = Math.Min(len, remaining);
                    t.Text = t.Text.Remove(0, cut);
                    remaining -= cut;
                }

                pos += len;
                if (done && remaining <= 0) break;
            }
        }

        #endregion

        #region Logger

        private void Log(string tag, string msg)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] [{tag}] {msg}");
        }

        #endregion

        #region Symmetric Cryptography (Must match the ASMX Service Logic)

        static string CallKey()
        {
            return "1bJTd2SauPv5Garuaq0Ig43uqq5NJOEw94wxdZTpUpFB9GmyPk677gJvC1Ro6sbAvKR4pVwtxdCfuoZDb6hJ5bVQKqlfihJfSYZtxVrVU270JhFbqTmYskatMTgPyjvv99CF2Te8ecYs2SPxyZAF0YwOCNOWmsyqN5y9tq2Kw2pjoiDs5gIHuw5U49JzOB6otS7kThBJEH9A76u4uUvR8DKbVcBrWu5qSJGEnbsXNfJdq5L2D8QgRdVsXHp2A7j1X2n4WIISvU1V9koIySNisHFBTcWJS0sC5BTFwrtfLEE9lEwz2bxHQpWJiu12ZeKpi7oUSqeb";
        }

        static string PasswordEncrypt(string inText, string key)
        {
            byte[] bytesBuff = Encoding.Unicode.GetBytes(inText);
            using (Aes aesAlg = Aes.Create())
            {
                // Salt MUST match exactly with the ASMX.VB service
                byte[] salt = new byte[] { 73, 118, 97, 110, 32, 77, 101, 100, 118, 101, 100, 101, 118 };
                using (var crypto = new Rfc2898DeriveBytes(key, salt))
                {
                    aesAlg.Key = crypto.GetBytes(32);
                    aesAlg.IV = crypto.GetBytes(16);
                    using (var mStream = new MemoryStream())
                    {
                        using (var cStream = new CryptoStream(mStream, aesAlg.CreateEncryptor(), CryptoStreamMode.Write))
                        {
                            cStream.Write(bytesBuff, 0, bytesBuff.Length);
                            cStream.FlushFinalBlock();
                        }
                        return Convert.ToBase64String(mStream.ToArray());
                    }
                }
            }
        }

        static string PasswordDecrypt(string cryptTxt, string key)
        {
            // Handle Base64 URL character replacement
            cryptTxt = cryptTxt.Replace(" ", "+");
            byte[] bytesBuff = Convert.FromBase64String(cryptTxt);
            using (Aes aesAlg = Aes.Create())
            {
                byte[] salt = new byte[] { 73, 118, 97, 110, 32, 77, 101, 100, 118, 101, 100, 101, 118 };
                using (var crypto = new Rfc2898DeriveBytes(key, salt))
                {
                    aesAlg.Key = crypto.GetBytes(32);
                    aesAlg.IV = crypto.GetBytes(16);
                    using (var mStream = new MemoryStream())
                    {
                        using (var cStream = new CryptoStream(mStream, aesAlg.CreateDecryptor(), CryptoStreamMode.Write))
                        {
                            cStream.Write(bytesBuff, 0, bytesBuff.Length);
                            cStream.FlushFinalBlock();
                        }
                        return Encoding.Unicode.GetString(mStream.ToArray());
                    }
                }
            }
        }
        #endregion
    }
}
